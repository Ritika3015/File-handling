# -*- coding: utf-8 -*-
"""File,exception handling,logging, memory management.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EuwoILkoNYzz1PJq2xW9F71yVVUTDqK3

1) What is the difference between interpreted and compiled languages?

- Interpreted language means code is executed line by line by the interpreter at the runtime. It is slower than compiled because translation happens during execution. Example- Javascript, Ruby, etc

- Compiled language means code is converted to machine code first and then the execution is done by the compiler. Fast, because it's already translated into machine code. Example- C++, C, etc

2) What is exception handling in Python?

- Exception handling in Python is used to gracefully handle runtime errors and avoid program crashes.

3) What is the purpose of the finally block in exception handling?

- The finally block is used to define code that must run, no matter what happens in the try or except blocks — whether an exception is raised or not.

4) What is logging in Python?

- Python's logging module is used to record messages that describe what the application is doing. It's much better than using print() for debugging, especially in real applications.

5) What is the significance of the __del__ method in Python?

- The __del__ method in Python is a destructor — it's a special method that is automatically called when an object is about to be destroyed (i.e., when it's garbage collected).

6) What is the difference between import and from ... import in Python?

- import statement- Imports the entire module. You need to use the module name as a prefix to access functions, classes, or variables.

- from ... import statement- Imports specific attributes (functions, classes, variables) directly from a module. You can use them without the module prefix.

7) How can you handle multiple exceptions in Python?

- Handle Each Exception Separately- Use multiple except blocks, one for each exception type.
- Handle Multiple Exceptions in One Block- If you want to handle several exceptions the same way, you can group them in a tuple.
-  Catch-All Exception- Use this to catch any exception, especially in production code where you don’t want the program to crash.
- Use else and finally.

8) What is the purpose of the with statement when handling files in Python?

- Automatic File Closure- Ensures that the file is closed properly after its block of code runs—no need to explicitly call file.close().

- Cleaner and More Readable Code- Reduces boilerplate and avoids indentation issues.

- Exception Safety- If an error occurs inside the with block, Python still closes the file safely

9) What is the difference between multithreading and multiprocessing?

- Multithreading
- Since it happens in one processor, threads share same memory space and resources.
- Runs Concurrently (GIL)
- Best for tasks that are part of same application and need to share data or resources.
- Use case- input/output process like downloading the file, managing multiple tabs on browser.

- Multiprocessing
- Multiple cores/processors are there, each process has its own memory space and resources which are isolated from other process.
- Runs truly parallel on multiple CPU cores (no GIL).
- suitable for tasks that are independent and can run isolation.
- Example- some computations, server handling multiple requests simultaneously

10) What are the advantages of using logging in a program?

- Tracks Events and Errors
- Unlike print(), logs can be stored in files for future analysis and auditing.
- print() is suitable for quick debugging, but logging is structured and scalable, making it ideal for real-world applications.
- In multithreaded or large applications, logging helps trace the flow and catch issues that are hard to find with print().
- You can configure log formats, timestamps, and even create multiple loggers for different parts of your application.

11) What is memory management in Python?

- Python handles memory management automatically, but it still provides mechanisms and best practices for efficient use of memory.
- Automatic Garbage Collection: -
Python uses a garbage collector (GC) to free memory by removing objects that are no longer in use. It relies primarily on reference counting and secondarily on cyclic garbage collection.
- Reference Counting: -
Every object in Python has a reference count — the number of references to it.
When the count drops to zero (no references to the object), it is immediately destroyed.
- Cyclic Garbage Collection: -
Python’s garbage collector can detect reference cycles (objects referencing each other in a loop), which reference counting alone can’t clean up.
These cycles are collected by Python’s gc module.
- Memory Pools (via PyMalloc): -
Python uses PyMalloc, a specialized allocator, to manage small objects efficiently using memory pools. This improves speed and reduces fragmentation.

12) What are the basic steps involved in exception handling in Python?

- Use try Block- Wrap the code that might raise an exception inside a try block
- Use except Block- Handle specific or general exceptions using except.
- Use else Block (Optional)- Executes only if no exception occurs in the try block.
- Use finally Block (Optional)- Always executes whether or not an exception occurred. Often used to release resources.

13) Why is memory management important in Python?

- Memory management is a critical aspect of any programming language, including Python. Although Python handles much of it automatically, understanding and managing memory properly has a big impact on performance, stability, and scalability of your programs.

14) What is the role of try and except in exception handling?

- try Block
- Place the code that might cause an error inside try.
- Python runs this block normally, but watches for errors.

- except Block
- If an error occurs in try, Python jumps to except and runs it.
- You can handle specific exceptions or use a generic one.

15) How does Python's garbage collection system work?

- Python's garbage collection (GC) system is responsible for automatically freeing up memory by removing objects that are no longer needed. It uses a combination of:
- Reference Counting
- Cyclic Garbage Collection

16) What is the purpose of the else block in exception handling?

- The else block in Python's exception handling is used to define code that should run only if no exception occurs in the try block.

17) What are the common logging levels in Python?

- DEBUG- Detailed information, typically of interest only when diagnosing problems. It is the lowest logging level.

- INFO- Confirmation that things are working as expected.

- WARNING- An indication that something unexpected happened, or indicative of some problem in the near future (e.g., ‘disk space low’). The software is still working as expected.

- ERROR- Due to a more serious problem, the software has not been able to perform some function.

- CRITICAL- A very serious error, indicating that the program itself may be unable to continue running. It is the highest logging level.

18) What is the difference between os.fork() and multiprocessing in Python?

- os.fork() is a low-level system call (available only on Unix-like systems) that creates a child process by duplicating the current process. After fork(), you have two processes running the same code but with separate memory spaces.

- Multiprocessing is high-level module in Python to create and manage processes, designed to offer an easy interface similar to threading but for processes.

19) What is the importance of closing a file in Python?

-  Releases system resources
When you open a file, the operating system allocates resources (like file descriptors) to manage it.
Closing the file releases these resources, making them available for other processes or files.
If too many files remain open without closing, your program or system may run out of file descriptors, causing errors.

- Ensures data is written to disk
When writing to a file, data is often buffered (stored temporarily in memory) before being physically written to disk.
Closing the file flushes the buffer, ensuring all data is actually saved.
If you don’t close the file properly, some data might not be saved correctly.

- Prevents file corruption and inconsistent state
Open files might stay locked or in an inconsistent state if not properly closed.
Closing the file signals that you are done, so other programs or parts of your code can safely access the file afterward.

- Good programming practice
Explicitly closing files makes your code cleaner, more predictable, and easier to maintain.
It helps avoid subtle bugs related to file handling.

20) What is the difference between file.read() and file.readline() in Python?

- file.read()
- Reads the entire content of the file (or up to a specified number of bytes if you provide an argument).
- Returns a string containing everything.
- Moves the file cursor to the end of the file after reading.

- file.readline()
- Reads only one line from the file each time it is called.
- Returns a string containing that single line (including the newline \n character).
- Moves the file cursor to the start of the next line.

21) What is the logging module in Python used for?
- Debugging: Record detailed information about program execution to find and fix bugs.

- Monitoring: Keep track of application behavior in production to detect problems early.

- Auditing: Keep records of important events, like user actions or errors, for compliance and analysis.

- Error Reporting: Log error messages with details to understand failures and exceptions.

- Information Tracking: Log routine info messages such as startup/shutdown, configuration changes, or significant state changes.

22) What is the os module in Python used for in file handling?

- The os module in Python provides a way to interact with the operating system, and it’s very useful in file handling for tasks beyond just reading/writing files.

23) What are the challenges associated with memory management in Python?

- Automatic Garbage Collection Limitations-Python uses reference counting plus a cyclic garbage collector.
Objects involved in reference cycles (objects referencing each other) can sometimes cause memory leaks if not collected properly.

- Memory Fragmentation
Over time, repeated allocation and deallocation of objects can fragment memory, reducing efficiency.

- Large Objects and Data Structures
Handling very large lists, dictionaries, or custom objects can consume lots of memory and slow down the program.

- Unintended Object References
Holding references longer than needed (e.g., in global variables or caches) prevents garbage collection, causing memory bloat.

- Lack of Manual Control
Unlike languages like C/C++, Python abstracts memory management, so developers have limited control over when exactly memory is freed.

- Memory Overhead of Python Objects
Python objects have some inherent memory overhead compared to raw data, due to dynamic typing and internal bookkeeping.

24)  How do you raise an exception manually in Python?

- You can use the raise statement to manually trigger (raise) an exception whenever you want in your code. This is useful to enforce rules or signal errors.

25) Why is it important to use multithreading in certain applications?

- Improving Responsiveness (UI applications)
In GUI apps, multithreading keeps the interface responsive while doing background work (e.g., file loading, network requests).

- Handling I/O-bound Tasks
Threads can wait for slow operations like reading files, network communication, or database queries without blocking the entire program.

- Parallelism in Lightweight Tasks
When tasks involve waiting (e.g., API calls), multithreading allows other tasks to run during wait times.

- Resource Sharing
Threads share the same memory space, making communication and data sharing between threads simpler than with multiprocessing.

- Better CPU Utilization for Some Workloads
For I/O-bound programs, threads improve efficiency by overlapping waiting times.
"""

# 1)How can you open a file for writing in Python and write a string to it?

with open ("file.txt","w") as f:
  f.write("Hello PW skills!")

# 2)Write a Python program to read the contents of a file and print each line?

with open ("file.txt","r") as f:
  line=f.readline()
  print(line)

# 3)How would you handle a case where the file doesn't exist while trying to open it for reading?

try:
  f= open("file1.txt","rb")
except Exception as e:
  print("No such file exists as ",e)

# 4)Write a Python script that reads from one file and writes its content to another file?

with open ("file.txt","r") as f:
  with open ("file2.txt","w") as f1:
    f1.write(f.read())

# 5)How would you catch and handle division by zero error in Python?

try:
  5/0
except Exception as e:
  print("Error is",e)

# 6)Write a Python program that logs an error message to a log file when a division by zero exception occurs?

import logging

# Setup logging configuration
logging.basicConfig(filename='error.log',
                    level=logging.ERROR,
                    format='%(asctime)s - %(levelname)s - %(message)s')

def divide(a, b):
    try:
        result = a / b
        print(f"Result: {result}")
    except ZeroDivisionError as e:
        logging.error(f"Division by zero error: {e}")
        print("Error: Cannot divide by zero.")

# Example usage
divide(10, 0)

# 7)How do you log information at different levels (INFO, ERROR, WARNING) in Python using the logging module?

import logging

# Basic configuration for logging
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

logging.info("This is an info message")
logging.warning("This is a warning message")
logging.error("This is an error message")

# 8)Write a program to handle a file opening error using exception handling?

file_path = 'non_existent_file.txt'

try:
    with open(file_path, 'r') as file:
        content = file.read()
        print(content)
except FileNotFoundError:
    print(f"Error: The file '{file_path}' was not found.")
except IOError as e:
    print(f"An I/O error occurred: {e}")
except Exception as e:
    print(f"An unexpected error occurred: {e}")

# 9)How can you read a file line by line and store its content in a list in Python?

file_path = 'file.txt'

lines = []
with open(file_path, 'r') as file:
    for line in file:
        lines.append(line.rstrip('\n'))  # Remove trailing newline characters

print(lines)

# 10)How can you append data to an existing file in Python?

with open('file.txt', 'a') as file:
    file.write("This line will be appended.\n")

# 11)Write a Python program that uses a try-except block to handle an error when attempting to access a dictionary key that doesn't exist?

my_dict = {'name': 'Alice', 'age': 25}

try:
    # Attempt to access a non-existent key
    value = my_dict['address']
    print(f"Address: {value}")
except KeyError:
    print("Error: The key 'address' does not exist in the dictionary.")

# 12)Write a program that demonstrates using multiple except blocks to handle different types of exceptions?

def divide_and_access_element(a, b, lst, index):
    try:
        result = a / b                  # May raise ZeroDivisionError
        print(f"Division result: {result}")

        element = lst[index]           # May raise IndexError
        print(f"Element at index {index}: {element}")

        value = int("abc")             # May raise ValueError
        print(f"Converted value: {value}")

    except ZeroDivisionError:
        print("Error: Cannot divide by zero.")
    except IndexError:
        print("Error: List index out of range.")
    except ValueError:
        print("Error: Invalid value for conversion.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

# Example usage:
my_list = [1, 2, 3]
divide_and_access_element(10, 0, my_list, 2)   # Triggers ZeroDivisionError
divide_and_access_element(10, 2, my_list, 5)   # Triggers IndexError
divide_and_access_element(10, 2, my_list, 1)   # Triggers ValueError on conversion

# 13)How would you check if a file exists before attempting to read it in Python?

import os

file_path = 'file1.txt'

if os.path.exists(file_path):
    with open(file_path, 'r') as file:
        content = file.read()
        print(content)
else:
    print(f"The file '{file_path}' does not exist.")

# 14)Write a program that uses the logging module to log both informational and error messages.

import logging

# Configure logging: logs to file with time, level, and message
logging.basicConfig(filename='app.log',
                    level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

def divide_numbers(a, b):
    logging.info(f"Attempting to divide {a} by {b}")
    try:
        result = a / b
        logging.info(f"Division successful: result is {result}")
        return result
    except ZeroDivisionError as e:
        logging.error(f"Error occurred: {e}")
        return None

# Example usage
divide_numbers(10, 2)
divide_numbers(10, 0)

# 15)Write a Python program that prints the content of a file and handles the case when the file is empty.

import os

def print_file_contents(file_path):
    try:
        if not os.path.exists(file_path):
            print(f"Error: The file '{file_path}' does not exist.")
            return

        if os.stat(file_path).st_size == 0:
            print(f"The file '{file_path}' is empty.")
            return

        with open(file_path, 'r') as file:
            content = file.read()
            print("File contents:")
            print(content)

    except Exception as e:
        print(f"An error occurred: {e}")

# Example usage
file_name = 'example.txt'
print_file_contents(file_name)

# Commented out IPython magic to ensure Python compatibility.
# 16)Demonstrate how to use memory profiling to check the memory usage of a small program.

!pip install memory_profiler
# %load_ext memory_profiler

from memory_profiler import profile

@profile
def create_list():
    nums = [i for i in range(100000)]
    squares = [x**2 for x in nums]
    return squares

# 17)Write a Python program to create and write a list of numbers to a file, one number per line?

numbers = [10, 20, 30, 40, 50]

# Open a file in write mode
with open('numbers.txt', 'w') as file:
    for number in numbers:
        file.write(f"{number}\n")

# 18)How would you implement a basic logging setup that logs to a file with rotation after 1MB?

import logging
from logging.handlers import RotatingFileHandler

# Create a logger
logger = logging.getLogger('my_logger')
logger.setLevel(logging.DEBUG)

# Create a rotating file handler that logs up to 1MB and keeps 3 backups
handler = RotatingFileHandler('app.log', maxBytes=1*1024*1024, backupCount=3)
handler.setLevel(logging.DEBUG)

# Create a formatter and set it for the handler
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)

# Add the handler to the logger
logger.addHandler(handler)

# Example usage
logger.info("This is an info message.")
logger.error("This is an error message.")

# 19)Write a program that handles both IndexError and KeyError using a try-except block.

def handle_errors():
    my_list = [10, 20, 30]
    my_dict = {'a': 1, 'b': 2}

    try:
        # Accessing an invalid list index
        print("Accessing list element at index 5:")
        print(my_list[5])

        # Accessing a non-existent key in dictionary
        print("Accessing dictionary key 'z':")
        print(my_dict['z'])

    except IndexError as ie:
        print(f"IndexError caught: {ie}")

    except KeyError as ke:
        print(f"KeyError caught: {ke}")

    except Exception as e:
        print(f"An unexpected error occurred: {e}")

handle_errors()

# 20)How would you open a file and read its contents using a context manager in Python?

file_path = 'file.txt'

try:
    with open(file_path, 'r') as file:
        content = file.read()
        print(content)
except FileNotFoundError:
    print("The file was not found.")

# 21)Write a Python program that reads a file and prints the number of occurrences of a specific word.

import re

def count_word_occurrences(file_path, target_word):
    try:
        with open(file_path, 'r') as file:
            content = file.read().lower()
            # Use regex to find whole word matches, ignoring punctuation
            words = re.findall(r'\b' + re.escape(target_word.lower()) + r'\b', content)
            print(f"The word '{target_word}' occurs {len(words)} times in the file.")
    except FileNotFoundError:
        print(f"Error: The file '{file_path}' was not found.")
    except Exception as e:
        print(f"An error occurred: {e}")

file_name = 'file.txt'
word_to_search = 'example'
count_word_occurrences(file_name, word_to_search)

# 22)How can you check if a file is empty before attempting to read its contents?

file_path = 'file.txt'

try:
    with open(file_path, 'r') as f:
        first_char = f.read(1)
        if not first_char:
            print("The file is empty.")
        else:
            f.seek(0)
            content = f.read()
            print(content)
except FileNotFoundError:
    print("File does not exist.")

# 23)Write a Python program that writes to a log file when an error occurs during file handling.

import logging
logging.basicConfig(filename='error.log', level=logging.ERROR,
                    format='%(asctime)s - %(levelname)s - %(message)s')

try:
    with open("file.txt", "r") as f:
        content = f.read()
        print(content)
except FileNotFoundError as e:
    logging.error("File not found: %s", e)
except IOError as e:
    logging.error("I/O error occurred: %s", e)
except Exception as e:
    logging.error("An unexpected error occurred: %s", e)